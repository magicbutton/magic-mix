// Package openapiSubscriptions provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version (devel) DO NOT EDIT.
package officegraph

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// Defines values for SubscriptionsSubscriptionListSubscriptionParamsSelect.
const (
	SubscriptionsSubscriptionListSubscriptionParamsSelectApplicationId             SubscriptionsSubscriptionListSubscriptionParamsSelect = "applicationId"
	SubscriptionsSubscriptionListSubscriptionParamsSelectChangeType                SubscriptionsSubscriptionListSubscriptionParamsSelect = "changeType"
	SubscriptionsSubscriptionListSubscriptionParamsSelectClientState               SubscriptionsSubscriptionListSubscriptionParamsSelect = "clientState"
	SubscriptionsSubscriptionListSubscriptionParamsSelectCreatorId                 SubscriptionsSubscriptionListSubscriptionParamsSelect = "creatorId"
	SubscriptionsSubscriptionListSubscriptionParamsSelectEncryptionCertificate     SubscriptionsSubscriptionListSubscriptionParamsSelect = "encryptionCertificate"
	SubscriptionsSubscriptionListSubscriptionParamsSelectEncryptionCertificateId   SubscriptionsSubscriptionListSubscriptionParamsSelect = "encryptionCertificateId"
	SubscriptionsSubscriptionListSubscriptionParamsSelectExpirationDateTime        SubscriptionsSubscriptionListSubscriptionParamsSelect = "expirationDateTime"
	SubscriptionsSubscriptionListSubscriptionParamsSelectId                        SubscriptionsSubscriptionListSubscriptionParamsSelect = "id"
	SubscriptionsSubscriptionListSubscriptionParamsSelectIncludeResourceData       SubscriptionsSubscriptionListSubscriptionParamsSelect = "includeResourceData"
	SubscriptionsSubscriptionListSubscriptionParamsSelectLatestSupportedTlsVersion SubscriptionsSubscriptionListSubscriptionParamsSelect = "latestSupportedTlsVersion"
	SubscriptionsSubscriptionListSubscriptionParamsSelectLifecycleNotificationUrl  SubscriptionsSubscriptionListSubscriptionParamsSelect = "lifecycleNotificationUrl"
	SubscriptionsSubscriptionListSubscriptionParamsSelectNotificationQueryOptions  SubscriptionsSubscriptionListSubscriptionParamsSelect = "notificationQueryOptions"
	SubscriptionsSubscriptionListSubscriptionParamsSelectNotificationUrl           SubscriptionsSubscriptionListSubscriptionParamsSelect = "notificationUrl"
	SubscriptionsSubscriptionListSubscriptionParamsSelectNotificationUrlAppId      SubscriptionsSubscriptionListSubscriptionParamsSelect = "notificationUrlAppId"
	SubscriptionsSubscriptionListSubscriptionParamsSelectResource                  SubscriptionsSubscriptionListSubscriptionParamsSelect = "resource"
)

// Defines values for SubscriptionsSubscriptionGetSubscriptionParamsSelect.
const (
	SubscriptionsSubscriptionGetSubscriptionParamsSelectApplicationId             SubscriptionsSubscriptionGetSubscriptionParamsSelect = "applicationId"
	SubscriptionsSubscriptionGetSubscriptionParamsSelectChangeType                SubscriptionsSubscriptionGetSubscriptionParamsSelect = "changeType"
	SubscriptionsSubscriptionGetSubscriptionParamsSelectClientState               SubscriptionsSubscriptionGetSubscriptionParamsSelect = "clientState"
	SubscriptionsSubscriptionGetSubscriptionParamsSelectCreatorId                 SubscriptionsSubscriptionGetSubscriptionParamsSelect = "creatorId"
	SubscriptionsSubscriptionGetSubscriptionParamsSelectEncryptionCertificate     SubscriptionsSubscriptionGetSubscriptionParamsSelect = "encryptionCertificate"
	SubscriptionsSubscriptionGetSubscriptionParamsSelectEncryptionCertificateId   SubscriptionsSubscriptionGetSubscriptionParamsSelect = "encryptionCertificateId"
	SubscriptionsSubscriptionGetSubscriptionParamsSelectExpirationDateTime        SubscriptionsSubscriptionGetSubscriptionParamsSelect = "expirationDateTime"
	SubscriptionsSubscriptionGetSubscriptionParamsSelectId                        SubscriptionsSubscriptionGetSubscriptionParamsSelect = "id"
	SubscriptionsSubscriptionGetSubscriptionParamsSelectIncludeResourceData       SubscriptionsSubscriptionGetSubscriptionParamsSelect = "includeResourceData"
	SubscriptionsSubscriptionGetSubscriptionParamsSelectLatestSupportedTlsVersion SubscriptionsSubscriptionGetSubscriptionParamsSelect = "latestSupportedTlsVersion"
	SubscriptionsSubscriptionGetSubscriptionParamsSelectLifecycleNotificationUrl  SubscriptionsSubscriptionGetSubscriptionParamsSelect = "lifecycleNotificationUrl"
	SubscriptionsSubscriptionGetSubscriptionParamsSelectNotificationQueryOptions  SubscriptionsSubscriptionGetSubscriptionParamsSelect = "notificationQueryOptions"
	SubscriptionsSubscriptionGetSubscriptionParamsSelectNotificationUrl           SubscriptionsSubscriptionGetSubscriptionParamsSelect = "notificationUrl"
	SubscriptionsSubscriptionGetSubscriptionParamsSelectNotificationUrlAppId      SubscriptionsSubscriptionGetSubscriptionParamsSelect = "notificationUrlAppId"
	SubscriptionsSubscriptionGetSubscriptionParamsSelectResource                  SubscriptionsSubscriptionGetSubscriptionParamsSelect = "resource"
)

// MicrosoftGraphODataErrorsErrorDetails defines model for microsoft.graph.ODataErrors.ErrorDetails.
type MicrosoftGraphODataErrorsErrorDetails struct {
	Code    string  `json:"code"`
	Message string  `json:"message"`
	Target  *string `json:"target"`
}

// MicrosoftGraphODataErrorsInnerError The structure of this object is service-specific
type MicrosoftGraphODataErrorsInnerError = map[string]interface{}

// MicrosoftGraphODataErrorsMainError defines model for microsoft.graph.ODataErrors.MainError.
type MicrosoftGraphODataErrorsMainError struct {
	Code    string                                   `json:"code"`
	Details *[]MicrosoftGraphODataErrorsErrorDetails `json:"details,omitempty"`

	// InnerError The structure of this object is service-specific
	InnerError *MicrosoftGraphODataErrorsInnerError `json:"innerError,omitempty"`
	Message    string                               `json:"message"`
	Target     *string                              `json:"target"`
}

// MicrosoftGraphODataErrorsODataError defines model for microsoft.graph.ODataErrors.ODataError.
type MicrosoftGraphODataErrorsODataError struct {
	Error MicrosoftGraphODataErrorsMainError `json:"error"`
}

// MicrosoftGraphEntity defines model for microsoft.graph.entity.
type MicrosoftGraphEntity struct {
	// Id The unique idenfier for an entity. Read-only.
	Id *string `json:"id,omitempty"`
}

// MicrosoftGraphSubscription defines model for microsoft.graph.subscription.
type MicrosoftGraphSubscription struct {
	// ApplicationId Optional. Identifier of the application used to create the subscription. Read-only.
	ApplicationId *string `json:"applicationId"`

	// ChangeType Required. Indicates the type of change in the subscribed resource that will raise a change notification. The supported values are: created, updated, deleted. Multiple values can be combined using a comma-separated list. Note:  Drive root item and list change notifications support only the updated changeType. User and group change notifications support updated and deleted changeType. Use updated to receive notifications when user or group is created, updated or soft deleted.  Use deleted to receive notifications when user or group is permanently deleted.
	ChangeType *string `json:"changeType,omitempty"`

	// ClientState Required. Specifies the value of the clientState property sent by the service in each change notification. The maximum length is 128 characters. The client can check that the change notification came from the service by comparing the value of the clientState property sent with the subscription with the value of the clientState property received with each change notification.
	ClientState *string `json:"clientState"`

	// CreatorId Optional. Identifier of the user or service principal that created the subscription. If the app used delegated permissions to create the subscription, this field contains the id of the signed-in user the app called on behalf of. If the app used application permissions, this field contains the id of the service principal corresponding to the app. Read-only.
	CreatorId *string `json:"creatorId"`

	// EncryptionCertificate Optional. A base64-encoded representation of a certificate with a public key used to encrypt resource data in change notifications. Optional but required when includeResourceData is true.
	EncryptionCertificate *string `json:"encryptionCertificate"`

	// EncryptionCertificateId Optional. A custom app-provided identifier to help identify the certificate needed to decrypt resource data.
	EncryptionCertificateId *string `json:"encryptionCertificateId"`

	// ExpirationDateTime Required. Specifies the date and time when the webhook subscription expires. The time is in UTC, and can be an amount of time from subscription creation that varies for the resource subscribed to. For the maximum supported subscription length of time, see the table below.
	ExpirationDateTime *time.Time `json:"expirationDateTime,omitempty"`

	// Id The unique idenfier for an entity. Read-only.
	Id *string `json:"id,omitempty"`

	// IncludeResourceData Optional. When set to true, change notifications include resource data (such as content of a chat message).
	IncludeResourceData *bool `json:"includeResourceData"`

	// LatestSupportedTlsVersion Optional. Specifies the latest version of Transport Layer Security (TLS) that the notification endpoint, specified by notificationUrl, supports. The possible values are: v10, v11, v12, v13. For subscribers whose notification endpoint supports a version lower than the currently recommended version (TLS 1.2), specifying this property by a set timeline allows them to temporarily use their deprecated version of TLS before completing their upgrade to TLS 1.2. For these subscribers, not setting this property per the timeline would result in subscription operations failing. For subscribers whose notification endpoint already supports TLS 1.2, setting this property is optional. In such cases, Microsoft Graph defaults the property to v1_2.
	LatestSupportedTlsVersion *string `json:"latestSupportedTlsVersion"`

	// LifecycleNotificationUrl Required for Teams resources if  the expirationDateTime value is more than 1 hour from now; optional otherwise. The URL of the endpoint that receives lifecycle notifications, including subscriptionRemoved, reauthorizationRequired, and missed notifications. This URL must make use of the HTTPS protocol. For more information, see Reduce missing subscriptions and change notifications.
	LifecycleNotificationUrl *string `json:"lifecycleNotificationUrl"`

	// NotificationQueryOptions Optional. OData query options for specifying value for the targeting resource. Clients receive notifications when resource reaches the state matching the query options provided here. With this new property in the subscription creation payload along with all existing properties, Webhooks will deliver notifications whenever a resource reaches the desired state mentioned in the notificationQueryOptions property. For example, when the print job is completed or when a print job resource isFetchable property value becomes true etc.  Supported only for Universal Print Service. For more information, see Subscribe to change notifications from cloud printing APIs using Microsoft Graph.
	NotificationQueryOptions *string `json:"notificationQueryOptions"`

	// NotificationUrl Required. The URL of the endpoint that will receive the change notifications. This URL must make use of the HTTPS protocol. Any query string parameter included in the notificationUrl property will be included in the HTTP POST request when Microsoft Graph sends the change notifications.
	NotificationUrl *string `json:"notificationUrl,omitempty"`

	// NotificationUrlAppId Optional. The app ID that the subscription service can use to generate the validation token. This allows the client to validate the authenticity of the notification received.
	NotificationUrlAppId *string `json:"notificationUrlAppId"`

	// Resource Required. Specifies the resource that will be monitored for changes. Do not include the base URL (https://graph.microsoft.com/v1.0/). See the possible resource path values for each supported resource.
	Resource *string `json:"resource,omitempty"`
}

// MicrosoftGraphSubscriptionCollectionResponse defines model for microsoft.graph.subscriptionCollectionResponse.
type MicrosoftGraphSubscriptionCollectionResponse struct {
	OdataNextLink *string                       `json:"@odata.nextLink"`
	Value         *[]MicrosoftGraphSubscription `json:"value,omitempty"`
}

// Search defines model for search.
type Search = string

// Error defines model for error.
type Error = MicrosoftGraphODataErrorsODataError

// SubscriptionsSubscriptionListSubscriptionParams defines parameters for SubscriptionsSubscriptionListSubscription.
type SubscriptionsSubscriptionListSubscriptionParams struct {
	// Search Search items by search phrases
	Search *Search `form:"$search,omitempty" json:"$search,omitempty"`

	// Select Select properties to be returned
	Select *[]SubscriptionsSubscriptionListSubscriptionParamsSelect `form:"$select,omitempty" json:"$select,omitempty"`
}

// SubscriptionsSubscriptionListSubscriptionParamsSelect defines parameters for SubscriptionsSubscriptionListSubscription.
type SubscriptionsSubscriptionListSubscriptionParamsSelect string

// SubscriptionsSubscriptionDeleteSubscriptionParams defines parameters for SubscriptionsSubscriptionDeleteSubscription.
type SubscriptionsSubscriptionDeleteSubscriptionParams struct {
	// IfMatch ETag
	IfMatch *string `json:"If-Match,omitempty"`
}

// SubscriptionsSubscriptionGetSubscriptionParams defines parameters for SubscriptionsSubscriptionGetSubscription.
type SubscriptionsSubscriptionGetSubscriptionParams struct {
	// Select Select properties to be returned
	Select *[]SubscriptionsSubscriptionGetSubscriptionParamsSelect `form:"$select,omitempty" json:"$select,omitempty"`
}

// SubscriptionsSubscriptionGetSubscriptionParamsSelect defines parameters for SubscriptionsSubscriptionGetSubscription.
type SubscriptionsSubscriptionGetSubscriptionParamsSelect string

// SubscriptionsSubscriptionCreateSubscriptionJSONRequestBody defines body for SubscriptionsSubscriptionCreateSubscription for application/json ContentType.
type SubscriptionsSubscriptionCreateSubscriptionJSONRequestBody = MicrosoftGraphSubscription

// SubscriptionsSubscriptionUpdateSubscriptionJSONRequestBody defines body for SubscriptionsSubscriptionUpdateSubscription for application/json ContentType.
type SubscriptionsSubscriptionUpdateSubscriptionJSONRequestBody = MicrosoftGraphSubscription

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new C	lient, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// SubscriptionsSubscriptionListSubscription request
	SubscriptionsSubscriptionListSubscription(ctx context.Context, params *SubscriptionsSubscriptionListSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubscriptionsSubscriptionCreateSubscriptionWithBody request with any body
	SubscriptionsSubscriptionCreateSubscriptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SubscriptionsSubscriptionCreateSubscription(ctx context.Context, body SubscriptionsSubscriptionCreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubscriptionsSubscriptionDeleteSubscription request
	SubscriptionsSubscriptionDeleteSubscription(ctx context.Context, subscriptionId string, params *SubscriptionsSubscriptionDeleteSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubscriptionsSubscriptionGetSubscription request
	SubscriptionsSubscriptionGetSubscription(ctx context.Context, subscriptionId string, params *SubscriptionsSubscriptionGetSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubscriptionsSubscriptionUpdateSubscriptionWithBody request with any body
	SubscriptionsSubscriptionUpdateSubscriptionWithBody(ctx context.Context, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SubscriptionsSubscriptionUpdateSubscription(ctx context.Context, subscriptionId string, body SubscriptionsSubscriptionUpdateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubscriptionsSubscriptionReauthorize request
	SubscriptionsSubscriptionReauthorize(ctx context.Context, subscriptionId string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) SubscriptionsSubscriptionListSubscription(ctx context.Context, params *SubscriptionsSubscriptionListSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubscriptionsSubscriptionListSubscriptionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubscriptionsSubscriptionCreateSubscriptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubscriptionsSubscriptionCreateSubscriptionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubscriptionsSubscriptionCreateSubscription(ctx context.Context, body SubscriptionsSubscriptionCreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubscriptionsSubscriptionCreateSubscriptionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubscriptionsSubscriptionDeleteSubscription(ctx context.Context, subscriptionId string, params *SubscriptionsSubscriptionDeleteSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubscriptionsSubscriptionDeleteSubscriptionRequest(c.Server, subscriptionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubscriptionsSubscriptionGetSubscription(ctx context.Context, subscriptionId string, params *SubscriptionsSubscriptionGetSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubscriptionsSubscriptionGetSubscriptionRequest(c.Server, subscriptionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubscriptionsSubscriptionUpdateSubscriptionWithBody(ctx context.Context, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubscriptionsSubscriptionUpdateSubscriptionRequestWithBody(c.Server, subscriptionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubscriptionsSubscriptionUpdateSubscription(ctx context.Context, subscriptionId string, body SubscriptionsSubscriptionUpdateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubscriptionsSubscriptionUpdateSubscriptionRequest(c.Server, subscriptionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubscriptionsSubscriptionReauthorize(ctx context.Context, subscriptionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubscriptionsSubscriptionReauthorizeRequest(c.Server, subscriptionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewSubscriptionsSubscriptionListSubscriptionRequest generates requests for SubscriptionsSubscriptionListSubscription
func NewSubscriptionsSubscriptionListSubscriptionRequest(server string, params *SubscriptionsSubscriptionListSubscriptionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "$search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Select != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "$select", runtime.ParamLocationQuery, *params.Select); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSubscriptionsSubscriptionCreateSubscriptionRequest calls the generic SubscriptionsSubscriptionCreateSubscription builder with application/json body
func NewSubscriptionsSubscriptionCreateSubscriptionRequest(server string, body SubscriptionsSubscriptionCreateSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSubscriptionsSubscriptionCreateSubscriptionRequestWithBody(server, "application/json", bodyReader)
}

// NewSubscriptionsSubscriptionCreateSubscriptionRequestWithBody generates requests for SubscriptionsSubscriptionCreateSubscription with any type of body
func NewSubscriptionsSubscriptionCreateSubscriptionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSubscriptionsSubscriptionDeleteSubscriptionRequest generates requests for SubscriptionsSubscriptionDeleteSubscription
func NewSubscriptionsSubscriptionDeleteSubscriptionRequest(server string, subscriptionId string, params *SubscriptionsSubscriptionDeleteSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscription-id", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.IfMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-Match", headerParam0)
		}

	}

	return req, nil
}

// NewSubscriptionsSubscriptionGetSubscriptionRequest generates requests for SubscriptionsSubscriptionGetSubscription
func NewSubscriptionsSubscriptionGetSubscriptionRequest(server string, subscriptionId string, params *SubscriptionsSubscriptionGetSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscription-id", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Select != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "$select", runtime.ParamLocationQuery, *params.Select); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSubscriptionsSubscriptionUpdateSubscriptionRequest calls the generic SubscriptionsSubscriptionUpdateSubscription builder with application/json body
func NewSubscriptionsSubscriptionUpdateSubscriptionRequest(server string, subscriptionId string, body SubscriptionsSubscriptionUpdateSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSubscriptionsSubscriptionUpdateSubscriptionRequestWithBody(server, subscriptionId, "application/json", bodyReader)
}

// NewSubscriptionsSubscriptionUpdateSubscriptionRequestWithBody generates requests for SubscriptionsSubscriptionUpdateSubscription with any type of body
func NewSubscriptionsSubscriptionUpdateSubscriptionRequestWithBody(server string, subscriptionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscription-id", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSubscriptionsSubscriptionReauthorizeRequest generates requests for SubscriptionsSubscriptionReauthorize
func NewSubscriptionsSubscriptionReauthorizeRequest(server string, subscriptionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "subscription-id", runtime.ParamLocationPath, subscriptionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions/%s/microsoft.graph.reauthorize", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// SubscriptionsSubscriptionListSubscriptionWithResponse request
	SubscriptionsSubscriptionListSubscriptionWithResponse(ctx context.Context, params *SubscriptionsSubscriptionListSubscriptionParams, reqEditors ...RequestEditorFn) (*SubscriptionsSubscriptionListSubscriptionResponse, error)

	// SubscriptionsSubscriptionCreateSubscriptionWithBodyWithResponse request with any body
	SubscriptionsSubscriptionCreateSubscriptionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubscriptionsSubscriptionCreateSubscriptionResponse, error)

	SubscriptionsSubscriptionCreateSubscriptionWithResponse(ctx context.Context, body SubscriptionsSubscriptionCreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*SubscriptionsSubscriptionCreateSubscriptionResponse, error)

	// SubscriptionsSubscriptionDeleteSubscriptionWithResponse request
	SubscriptionsSubscriptionDeleteSubscriptionWithResponse(ctx context.Context, subscriptionId string, params *SubscriptionsSubscriptionDeleteSubscriptionParams, reqEditors ...RequestEditorFn) (*SubscriptionsSubscriptionDeleteSubscriptionResponse, error)

	// SubscriptionsSubscriptionGetSubscriptionWithResponse request
	SubscriptionsSubscriptionGetSubscriptionWithResponse(ctx context.Context, subscriptionId string, params *SubscriptionsSubscriptionGetSubscriptionParams, reqEditors ...RequestEditorFn) (*SubscriptionsSubscriptionGetSubscriptionResponse, error)

	// SubscriptionsSubscriptionUpdateSubscriptionWithBodyWithResponse request with any body
	SubscriptionsSubscriptionUpdateSubscriptionWithBodyWithResponse(ctx context.Context, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubscriptionsSubscriptionUpdateSubscriptionResponse, error)

	SubscriptionsSubscriptionUpdateSubscriptionWithResponse(ctx context.Context, subscriptionId string, body SubscriptionsSubscriptionUpdateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*SubscriptionsSubscriptionUpdateSubscriptionResponse, error)

	// SubscriptionsSubscriptionReauthorizeWithResponse request
	SubscriptionsSubscriptionReauthorizeWithResponse(ctx context.Context, subscriptionId string, reqEditors ...RequestEditorFn) (*SubscriptionsSubscriptionReauthorizeResponse, error)
}

type SubscriptionsSubscriptionListSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *MicrosoftGraphSubscriptionCollectionResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SubscriptionsSubscriptionListSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubscriptionsSubscriptionListSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubscriptionsSubscriptionCreateSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *MicrosoftGraphSubscription
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SubscriptionsSubscriptionCreateSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubscriptionsSubscriptionCreateSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubscriptionsSubscriptionDeleteSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SubscriptionsSubscriptionDeleteSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubscriptionsSubscriptionDeleteSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubscriptionsSubscriptionGetSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *MicrosoftGraphSubscription
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SubscriptionsSubscriptionGetSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubscriptionsSubscriptionGetSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubscriptionsSubscriptionUpdateSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *MicrosoftGraphSubscription
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SubscriptionsSubscriptionUpdateSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubscriptionsSubscriptionUpdateSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubscriptionsSubscriptionReauthorizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SubscriptionsSubscriptionReauthorizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubscriptionsSubscriptionReauthorizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// SubscriptionsSubscriptionListSubscriptionWithResponse request returning *SubscriptionsSubscriptionListSubscriptionResponse
func (c *ClientWithResponses) SubscriptionsSubscriptionListSubscriptionWithResponse(ctx context.Context, params *SubscriptionsSubscriptionListSubscriptionParams, reqEditors ...RequestEditorFn) (*SubscriptionsSubscriptionListSubscriptionResponse, error) {
	rsp, err := c.SubscriptionsSubscriptionListSubscription(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubscriptionsSubscriptionListSubscriptionResponse(rsp)
}

// SubscriptionsSubscriptionCreateSubscriptionWithBodyWithResponse request with arbitrary body returning *SubscriptionsSubscriptionCreateSubscriptionResponse
func (c *ClientWithResponses) SubscriptionsSubscriptionCreateSubscriptionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubscriptionsSubscriptionCreateSubscriptionResponse, error) {
	rsp, err := c.SubscriptionsSubscriptionCreateSubscriptionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubscriptionsSubscriptionCreateSubscriptionResponse(rsp)
}

func (c *ClientWithResponses) SubscriptionsSubscriptionCreateSubscriptionWithResponse(ctx context.Context, body SubscriptionsSubscriptionCreateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*SubscriptionsSubscriptionCreateSubscriptionResponse, error) {
	rsp, err := c.SubscriptionsSubscriptionCreateSubscription(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubscriptionsSubscriptionCreateSubscriptionResponse(rsp)
}

// SubscriptionsSubscriptionDeleteSubscriptionWithResponse request returning *SubscriptionsSubscriptionDeleteSubscriptionResponse
func (c *ClientWithResponses) SubscriptionsSubscriptionDeleteSubscriptionWithResponse(ctx context.Context, subscriptionId string, params *SubscriptionsSubscriptionDeleteSubscriptionParams, reqEditors ...RequestEditorFn) (*SubscriptionsSubscriptionDeleteSubscriptionResponse, error) {
	rsp, err := c.SubscriptionsSubscriptionDeleteSubscription(ctx, subscriptionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubscriptionsSubscriptionDeleteSubscriptionResponse(rsp)
}

// SubscriptionsSubscriptionGetSubscriptionWithResponse request returning *SubscriptionsSubscriptionGetSubscriptionResponse
func (c *ClientWithResponses) SubscriptionsSubscriptionGetSubscriptionWithResponse(ctx context.Context, subscriptionId string, params *SubscriptionsSubscriptionGetSubscriptionParams, reqEditors ...RequestEditorFn) (*SubscriptionsSubscriptionGetSubscriptionResponse, error) {
	rsp, err := c.SubscriptionsSubscriptionGetSubscription(ctx, subscriptionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubscriptionsSubscriptionGetSubscriptionResponse(rsp)
}

// SubscriptionsSubscriptionUpdateSubscriptionWithBodyWithResponse request with arbitrary body returning *SubscriptionsSubscriptionUpdateSubscriptionResponse
func (c *ClientWithResponses) SubscriptionsSubscriptionUpdateSubscriptionWithBodyWithResponse(ctx context.Context, subscriptionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubscriptionsSubscriptionUpdateSubscriptionResponse, error) {
	rsp, err := c.SubscriptionsSubscriptionUpdateSubscriptionWithBody(ctx, subscriptionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubscriptionsSubscriptionUpdateSubscriptionResponse(rsp)
}

func (c *ClientWithResponses) SubscriptionsSubscriptionUpdateSubscriptionWithResponse(ctx context.Context, subscriptionId string, body SubscriptionsSubscriptionUpdateSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*SubscriptionsSubscriptionUpdateSubscriptionResponse, error) {
	rsp, err := c.SubscriptionsSubscriptionUpdateSubscription(ctx, subscriptionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubscriptionsSubscriptionUpdateSubscriptionResponse(rsp)
}

// SubscriptionsSubscriptionReauthorizeWithResponse request returning *SubscriptionsSubscriptionReauthorizeResponse
func (c *ClientWithResponses) SubscriptionsSubscriptionReauthorizeWithResponse(ctx context.Context, subscriptionId string, reqEditors ...RequestEditorFn) (*SubscriptionsSubscriptionReauthorizeResponse, error) {
	rsp, err := c.SubscriptionsSubscriptionReauthorize(ctx, subscriptionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubscriptionsSubscriptionReauthorizeResponse(rsp)
}

// ParseSubscriptionsSubscriptionListSubscriptionResponse parses an HTTP response from a SubscriptionsSubscriptionListSubscriptionWithResponse call
func ParseSubscriptionsSubscriptionListSubscriptionResponse(rsp *http.Response) (*SubscriptionsSubscriptionListSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubscriptionsSubscriptionListSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest MicrosoftGraphSubscriptionCollectionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSubscriptionsSubscriptionCreateSubscriptionResponse parses an HTTP response from a SubscriptionsSubscriptionCreateSubscriptionWithResponse call
func ParseSubscriptionsSubscriptionCreateSubscriptionResponse(rsp *http.Response) (*SubscriptionsSubscriptionCreateSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubscriptionsSubscriptionCreateSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest MicrosoftGraphSubscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSubscriptionsSubscriptionDeleteSubscriptionResponse parses an HTTP response from a SubscriptionsSubscriptionDeleteSubscriptionWithResponse call
func ParseSubscriptionsSubscriptionDeleteSubscriptionResponse(rsp *http.Response) (*SubscriptionsSubscriptionDeleteSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubscriptionsSubscriptionDeleteSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSubscriptionsSubscriptionGetSubscriptionResponse parses an HTTP response from a SubscriptionsSubscriptionGetSubscriptionWithResponse call
func ParseSubscriptionsSubscriptionGetSubscriptionResponse(rsp *http.Response) (*SubscriptionsSubscriptionGetSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubscriptionsSubscriptionGetSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest MicrosoftGraphSubscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSubscriptionsSubscriptionUpdateSubscriptionResponse parses an HTTP response from a SubscriptionsSubscriptionUpdateSubscriptionWithResponse call
func ParseSubscriptionsSubscriptionUpdateSubscriptionResponse(rsp *http.Response) (*SubscriptionsSubscriptionUpdateSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubscriptionsSubscriptionUpdateSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest MicrosoftGraphSubscription
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSubscriptionsSubscriptionReauthorizeResponse parses an HTTP response from a SubscriptionsSubscriptionReauthorizeWithResponse call
func ParseSubscriptionsSubscriptionReauthorizeResponse(rsp *http.Response) (*SubscriptionsSubscriptionReauthorizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubscriptionsSubscriptionReauthorizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List subscriptions
	// (GET /subscriptions)
	SubscriptionsSubscriptionListSubscription(ctx echo.Context, params SubscriptionsSubscriptionListSubscriptionParams) error
	// Create subscription
	// (POST /subscriptions)
	SubscriptionsSubscriptionCreateSubscription(ctx echo.Context) error
	// Delete subscription
	// (DELETE /subscriptions/{subscription-id})
	SubscriptionsSubscriptionDeleteSubscription(ctx echo.Context, subscriptionId string, params SubscriptionsSubscriptionDeleteSubscriptionParams) error
	// Get subscription
	// (GET /subscriptions/{subscription-id})
	SubscriptionsSubscriptionGetSubscription(ctx echo.Context, subscriptionId string, params SubscriptionsSubscriptionGetSubscriptionParams) error
	// Update subscription
	// (PATCH /subscriptions/{subscription-id})
	SubscriptionsSubscriptionUpdateSubscription(ctx echo.Context, subscriptionId string) error
	// Invoke action reauthorize
	// (POST /subscriptions/{subscription-id}/microsoft.graph.reauthorize)
	SubscriptionsSubscriptionReauthorize(ctx echo.Context, subscriptionId string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SubscriptionsSubscriptionListSubscription converts echo context to params.
func (w *ServerInterfaceWrapper) SubscriptionsSubscriptionListSubscription(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SubscriptionsSubscriptionListSubscriptionParams
	// ------------- Optional query parameter "$search" -------------

	err = runtime.BindQueryParameter("form", false, false, "$search", ctx.QueryParams(), &params.Search)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $search: %s", err))
	}

	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", false, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SubscriptionsSubscriptionListSubscription(ctx, params)
	return err
}

// SubscriptionsSubscriptionCreateSubscription converts echo context to params.
func (w *ServerInterfaceWrapper) SubscriptionsSubscriptionCreateSubscription(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SubscriptionsSubscriptionCreateSubscription(ctx)
	return err
}

// SubscriptionsSubscriptionDeleteSubscription converts echo context to params.
func (w *ServerInterfaceWrapper) SubscriptionsSubscriptionDeleteSubscription(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "subscription-id" -------------
	var subscriptionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "subscription-id", runtime.ParamLocationPath, ctx.Param("subscription-id"), &subscriptionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter subscription-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SubscriptionsSubscriptionDeleteSubscriptionParams

	headers := ctx.Request().Header
	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for If-Match, got %d", n))
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter If-Match: %s", err))
		}

		params.IfMatch = &IfMatch
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SubscriptionsSubscriptionDeleteSubscription(ctx, subscriptionId, params)
	return err
}

// SubscriptionsSubscriptionGetSubscription converts echo context to params.
func (w *ServerInterfaceWrapper) SubscriptionsSubscriptionGetSubscription(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "subscription-id" -------------
	var subscriptionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "subscription-id", runtime.ParamLocationPath, ctx.Param("subscription-id"), &subscriptionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter subscription-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SubscriptionsSubscriptionGetSubscriptionParams
	// ------------- Optional query parameter "$select" -------------

	err = runtime.BindQueryParameter("form", false, false, "$select", ctx.QueryParams(), &params.Select)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter $select: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SubscriptionsSubscriptionGetSubscription(ctx, subscriptionId, params)
	return err
}

// SubscriptionsSubscriptionUpdateSubscription converts echo context to params.
func (w *ServerInterfaceWrapper) SubscriptionsSubscriptionUpdateSubscription(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "subscription-id" -------------
	var subscriptionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "subscription-id", runtime.ParamLocationPath, ctx.Param("subscription-id"), &subscriptionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter subscription-id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SubscriptionsSubscriptionUpdateSubscription(ctx, subscriptionId)
	return err
}

// SubscriptionsSubscriptionReauthorize converts echo context to params.
func (w *ServerInterfaceWrapper) SubscriptionsSubscriptionReauthorize(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "subscription-id" -------------
	var subscriptionId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "subscription-id", runtime.ParamLocationPath, ctx.Param("subscription-id"), &subscriptionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter subscription-id: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SubscriptionsSubscriptionReauthorize(ctx, subscriptionId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/subscriptions", wrapper.SubscriptionsSubscriptionListSubscription)
	router.POST(baseURL+"/subscriptions", wrapper.SubscriptionsSubscriptionCreateSubscription)
	router.DELETE(baseURL+"/subscriptions/:subscription-id", wrapper.SubscriptionsSubscriptionDeleteSubscription)
	router.GET(baseURL+"/subscriptions/:subscription-id", wrapper.SubscriptionsSubscriptionGetSubscription)
	router.PATCH(baseURL+"/subscriptions/:subscription-id", wrapper.SubscriptionsSubscriptionUpdateSubscription)
	router.POST(baseURL+"/subscriptions/:subscription-id/microsoft.graph.reauthorize", wrapper.SubscriptionsSubscriptionReauthorize)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"e7ukd1d3/woAAP//WaGkG2Q7AAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
